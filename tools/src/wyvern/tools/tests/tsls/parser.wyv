module parser

import wyvern.util.matching.regex
import tsls.lexer
import wyvern.ast
import wyvern.Int
import wyvern.option
import debug

// local bindings to make things easier
val tokens = lexer.tokens
type AST = ast.AST

// let bind the operator regular expression, because it's annoying to comment out in debugging since it has */ in it
val operatorRegex = "[\\+\\-\\*/]"

def parse(input:String):option.Option
	// Create a scanner configuration, setting up the whitespace operator
	val config = lexer.makeScannerConfig(regex("[ \n\t]+"))

	// Add regular expressions and corresponding tokens
	config.addTokenKind(regex("\\d+")      , tokens.NUMBER)
	config.addTokenKind(regex(operatorRegex), tokens.OPERATOR)
	config.addTokenKind(regex("\\z")       , tokens.EOF)
	
	val scanner = lexer.makeScanner(config, input)
	doParse(scanner)
	
def doParse(scanner:lexer.Scanner):option.Option
	debug.print("start")
	val t = scanner.nextToken()
	(t.kind() == tokens.NUMBER).ifTrue(
	  () => parseWithOneExpr(scanner, ast.int(Int.from(t.print()))),
	  () => option.None()
	)

def parseWithOneExpr(scanner:lexer.Scanner, exp:AST):option.Option
	debug.print("p1")
	val t = scanner.nextToken()
	(t.kind() == tokens.EOF).ifTrue(
		() => option.Some(exp),
		() => (t.kind() == tokens.NUMBER).ifTrue(
			() => parseWithTwoExprs(scanner, exp, ast.int(Int.from(t.print())), false),
			() => option.None()
		)
	)

def parseWithTwoExprs(scanner:lexer.Scanner, exp1:AST, exp2:AST,
                      moreOnStack:Boolean):option.Option
	def compose(exp3:AST):option.Option
		val expOption : option.Option = parseWithTwoExprs(scanner, exp2, exp3, true)
		expOption.flatMap((expResult) => parseWithTwoExprs(scanner, exp1,expResult, moreOnStack))
	debug.print("p2")
	val t = scanner.nextToken()
	(t.kind() == tokens.OPERATOR).ifTrue(
		() => moreOnStack.ifTrue(
			() => option.Some(ast.call(exp1,t.print(),exp2)),
		    () => parseWithOneExpr(scanner, ast.call(exp1,t.print(),exp2))
		),
		() => (t.kind() == tokens.NUMBER).ifTrue(
			() => compose(ast.int(Int.from(t.print()))),
			() => option.None()
		)
	)
	
/* stackless version
function twoExpressions(scanner, exp1, exp2)
	t = scanner.getToken()
	if t is an operator o
		return oneExpression(scanner, o(exp1,exp2))
	else if t is a number n
		let e = twoExpressions(scanner, exp2, constant(n))
		return twoExpressions(scanner, exp1, e)
	else
		return error // EOF or unexpected
*/
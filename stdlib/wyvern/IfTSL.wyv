module IfTSL

import wyvern.ast
import wyvern.option
import wyvern.util.matching.regex

def thenMatch(input : String) : regex.Match
  val thenRegex = regex("^then\n")
  val mOpt = thenRegex.findPrefixMatchOf(input)
  mOpt.getOrElse(() => regex.makeMatch("", input))

def elseMatch(input : String) : regex.Match
  val thenRegex = regex("^else\n")
  val mOpt = thenRegex.findPrefixMatchOf(input)
  mOpt.getOrElse(() => regex.makeMatch("", input))

def indentedBlockMatch(input : String) : regex.Match
  val blockRegex = regex("(\\s[^\n]*\n)+")
  val blockMatchOpt = blockRegex.findPrefixMatchOf(input)

  val emptymatch = regex.makeMatch("", input)
  val m : regex.Match = blockMatchOpt.getOrElse(() => emptymatch)
  m

type AST = ast.AST

type IfExpr
  def evalTrue() : Dyn
  def evalFalse() : Dyn
  metadata new
    def parseTSL(input : String) : option.Option
      val trimmedInput = ast.stripLeadingWhitespace(input)
      val tm = thenMatch(trimmedInput)
      val trueMatch = indentedBlockMatch(tm.after())
      val em = elseMatch(trueMatch.after())
      val trueAST : AST = ast.parseExpression(ast.stripLeadingWhitespace(trueMatch.matched()))
      val falseAST : AST = ast.parseExpression(ast.stripLeadingWhitespace(em.after()))
      val trueDefn = ast.defn("evalTrue", ast.types.dyn(), trueAST)
      val falseDefn = ast.defn("evalFalse", ast.types.dyn(), falseAST)
      option.Some(ast.twoDeclObject(trueDefn, falseDefn))

def doif(condition : Boolean, body : IfExpr) : Dyn
  condition.ifTrue(() => body.evalTrue(), () => body.evalFalse())